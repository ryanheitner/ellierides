<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/GridLayout1"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent"
    android:background="@drawable/cover"
    tools:context=".GridLayoutActivity">


</FrameLayout>



 View.OnTouchListener l = new View.OnTouchListener() {
            @Override
            public boolean onTouch(View view, MotionEvent event) {
                if (navigate(event)) return true;
                int action = event.getAction();
                switch (action) {
                    case MotionEvent.ACTION_DOWN:
                        if ((touchedImage(matrixEllieDad, ellieDad1Layer, event) || (touchedImage(matrixEllieDad, ellieDad2Layer, event)))) {
                            animateEllieDad();
                        } else if (touchedImageBigger(matrixButterfly1f, butterfly1Layer, event, 25)) {
                            animateButterfly1();
                        } else if (touchedImageBigger(matrixButterfly2f, butterfly2Layer, event, 50)) { // allow a greater tolerance for touch
                            animateButterfly2();
                        } else if (touchedImageBigger(matrixSnail, snailLayer, event, 200)) { // allow a greater tolerance for touch
                            animateSnail();
                        } else if (touchedImage(matrixGrass, grassLayer, event)) {
                            animateGrass(event);
                        }
                        layeredImageView.invalidate();
                        return true;
                    case MotionEvent.ACTION_OUTSIDE:
                    case MotionEvent.ACTION_UP:
                    case MotionEvent.ACTION_CANCEL:
                        return true;
                }
                return false;
            }


            private void animateGrass(MotionEvent event) {
                final float xTouch = event.getX() ;
                final float yTouch = event.getY() ;


                Drawable drawable;
                Random r = new Random();
                int x = r.nextInt(7) + 1;
                String fileName = "flower" + x;
                int drawableResourceId = res.getIdentifier(fileName, "drawable", context.getPackageName());
                drawable = res.getDrawable(drawableResourceId);
                Assert.assertNotNull("Must no be null", drawable);

                drawable.setBounds(0, 0, (int) (drawable.getIntrinsicWidth()), (int) (drawable.getIntrinsicHeight()));

                final float[] values = new float[9];
                matrixGrass.getValues(values);
                float grassX = values[Matrix.MTRANS_X];
                float grassY = values[Matrix.MTRANS_Y];


                final Matrix matrixFlower = new Matrix();
                float originX = (xTouch - (0.5f * drawable.getIntrinsicWidth())) * imageWidthProportion;
                float originY = (yTouch - (0.5f * drawable.getIntrinsicHeight())) * imageHeightProportion;

                float maxX = (grassX + grassLayer.getDrawable().getIntrinsicWidth() - (0.5f * drawable.getIntrinsicWidth())) ;
                float maxY = (grassY + grassLayer.getDrawable().getIntrinsicHeight() - (0.5f * drawable.getIntrinsicHeight())) ;
                originX = Math.min(originX, maxX);
                originY = Math.min(originY, maxY);
                matrixFlower.preTranslate(originX, originY);
                layeredImageView.addLayer(1,drawable, matrixFlower);
            }

            private void animateSnail() {
                final Runnable slide = new Runnable() {
                    @Override
                    public void run() {
                        Animation snailAnim = AnimationUtils.loadAnimation(getActivity(), R.anim.snail);
                        snailLayer.startLayerAnimation(snailAnim);
                    }
                };
                slide.run();
            }

            private void animateEllieDad() {
                if (!ellieDad1Layer.isOn()) {
                    ellieDad2Layer.setAlpha(255);
                    ellieDad1Layer.setAlpha(0);
                } else {
                    ellieDad2Layer.setAlpha(0);
                    ellieDad1Layer.setAlpha(255);
                }
                ellieDad1Layer.setOn(!ellieDad1Layer.isOn());
            }
            private void animateButterfly1() {
                private void animateButterfly1() {
                    final float[] values = new float[9];
                    matrixButterfly1.getValues(values);
                    butterfly1Layer.setXoffset(30);
                    matrixButterfly1 = butterfly1Layer.getMatrix();
                    matrixButterfly1.getValues(values);
                }
            }


            private void animateButterfly2() {
                countDownTimer2 = new CountDownTimer(30000, 200) {
                    public void onTick(long millisUntilFinished) {
                        final Runnable fly = new Runnable() {
                            @Override
                            public void run() {
                                Random r = new Random();
                                TranslateAnimation translateAnimation = new TranslateAnimation(0, r.nextInt(90) - 45, 0, r.nextInt(90) - 41);
                                translateAnimation.setDuration(180);
                                butterfly2Layer.startLayerAnimation(translateAnimation);
                                butterfly2Layer.setFillAfter(true);
                                Animation.AnimationListener animationListener = new Animation.AnimationListener() {
                                    @Override
                                    public void onAnimationStart(Animation animation) {

                                    }

                                    @Override
                                    public void onAnimationEnd(Animation animation) {

                                    }

                                    @Override
                                    public void onAnimationRepeat(Animation animation) {
                                    }
                                };
                                translateAnimation.setAnimationListener(animationListener);
                            }
                        };
                        fly.run();
                    }

                    public void onFinish() {
                    }
                }.start();
            }


        };




















    // Minimum text size for this text view
    public static final float MIN_TEXT_SIZE = 15;

    // Interface for resize notifications
    public interface OnTextResizeListener {
        public void onTextResize(TextView textView, float oldSize, float newSize);
    }

    // Our ellipse string
    private static final String mEllipsis = "...";

    // Registered resize listener
    private OnTextResizeListener mTextResizeListener;

    // Flag for text and/or size changes to force a resize
    private boolean mNeedsResize = false;

    // Text size that is set from code. This acts as a starting point for resizing
    private float mTextSize;

    // Temporary upper bounds on the starting text size
    private float mMaxTextSize = 0;

    // Lower bounds for text size
    private float mMinTextSize = MIN_TEXT_SIZE;

    // Text view line spacing multiplier
    private float mSpacingMult = 1.0f;

    // Text view additional line spacing
    private float mSpacingAdd = 0.0f;

    // Add ellipsis to text that overflows at the smallest text size
    private boolean mAddEllipsis = true;

    // Default constructor override
    public AutoSizeFontTextView(Context context) {
        this(context, null);
    }

    // Default constructor when inflating from XML file
    public AutoSizeFontTextView(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    // Default constructor override
    public AutoSizeFontTextView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        mTextSize = getTextSize();
    }

    /**
     * When text changes, set the force resize flag to true and reset the text size.
     * before and after is the length of the string
    @Override
    protected void onTextChanged(final CharSequence text, final int start, final int before, final int after) {
        mNeedsResize = true;
        // Since this view may be reused, it is good to reset the text size
        resetTextSize();
    }

    /**
     * Register listener to receive resize notifications
     * @param listener
     */
    public void setOnResizeListener(OnTextResizeListener listener) {
        mTextResizeListener = listener;
    }

    /**
     * Override the set text size to update our internal reference values
     */
    @Override
    public void setTextSize(float size) {
        super.setTextSize(size);
        mTextSize = getTextSize();
    }

    /**
     * Override the set text size to update our internal reference values
     */
    @Override
    public void setTextSize(int unit, float size) {
        super.setTextSize(unit, size);
        mTextSize = getTextSize();
    }

    /**
     * Override the set line spacing to update our internal reference values
     */
    @Override
    public void setLineSpacing(float add, float mult) {
        super.setLineSpacing(add, mult);
        mSpacingMult = mult;
        mSpacingAdd = add;
    }

    /**
     * Set the upper text size limit and invalidate the view
     * @param maxTextSize
     */
    public void setMaxTextSize(float maxTextSize) {
        mMaxTextSize = maxTextSize;
        requestLayout();
        invalidate();
    }

    /**
     * Return upper text size limit
     * @return
     */
    public float getMaxTextSize() {
        return mMaxTextSize;
    }

    /**
     * Set the lower text size limit and invalidate the view
     * @param minTextSize
     */
    public void setMinTextSize(float minTextSize) {
        mMinTextSize = minTextSize;
        requestLayout();
        invalidate();
    }

    /**
     * Return lower text size limit
     * @return
     */
    public float getMinTextSize() {
        return mMinTextSize;
    }

    /**
     * Set flag to add ellipsis to text that overflows at the smallest text size
     * @param addEllipsis
     */
    public void setAddEllipsis(boolean addEllipsis) {
        mAddEllipsis = addEllipsis;
    }

    /**
     * Return flag to add ellipsis to text that overflows at the smallest text size
     * @return
     */
    public boolean getAddEllipsis() {
        return mAddEllipsis;
    }

    /**
     * Reset the text to the original size
     */
    public void resetTextSize() {
        if(mTextSize > 0) {
            super.setTextSize(TypedValue.COMPLEX_UNIT_PX, mTextSize);
            mMaxTextSize = mTextSize;
        }
    }

    /**
     * Resize text after measuring
     */






















